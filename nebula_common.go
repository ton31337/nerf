package nerf

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"os/exec"
	"path"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig"
	"go.uber.org/zap"
)

// Certificate struct for certificates generated for Nebula
type Certificate struct {
	Ca  string
	Crt string
	Key string
}

// LightHouse struct to define Nebula internal (overlay) IP address,
// and public (how to reach the real host in the mesh) IP address.
type LightHouse struct {
	NebulaIP string
	PublicIP string
}

// Nebula struct to store all the relevant data to generate config.yml for Nebula
type Nebula struct {
	Certificate *Certificate
	LightHouse  *LightHouse
}

type GaidysResponse struct {
	Hostname    string
	IpAddresses []string
}

// NewCertificate stores ca.crt, client.crt, client.key
func NewCertificate(Ca string, Crt string, Key string) *Certificate {
	return &Certificate{
		Ca:  Ca,
		Crt: Crt,
		Key: Key,
	}
}

// NebulaStart starts Nebula instance in foreground
func NebulaStart() (int, error) {
	var err error

	cmd := exec.Command(NebulaExecutable(), "-config", path.Join(NebulaDir(), "config.yml"))
	err = cmd.Start()
	if err != nil {
		return -1, err
	}

	go func() {
		err = cmd.Wait()
	}()

	return cmd.Process.Pid, err
}

// NebulaGenerateConfig generate config.yml
func NebulaGenerateConfig(userTeams []string) (string, error) {
	var generatedConfig bytes.Buffer

	NebulaGenerateCertificate(userTeams)

	configTemplate := `# Generated by Nerf!

pki:
  ca: |
{{ .Certificate.Ca | indent 4 }}
  cert: |
{{ .Certificate.Crt | indent 4 }}
  key: |
{{ .Certificate.Key | indent 4 }}
static_host_map:
  "{{ .LightHouse.NebulaIP }}": ["{{ .LightHouse.PublicIP }}:4242"]

lighthouse:
  am_lighthouse: false
  interval: 60
  hosts:
    - {{ .LightHouse.NebulaIP }}

listen:
  host: 0.0.0.0
  port: 4242

local_range: {{ .Subnet }}

tun:
  disabled: false
  dev: nebula1
  unsafe_routes:
    - route: 0.0.0.0/1
      via: {{ .LightHouse.NebulaIP }}
    - route: 128.0.0.0/1
      via: {{ .LightHouse.NebulaIP }}

firewall:
  outbound:
    - port: any
      proto: any
      host: any
`
	nebulaConfigTemplate := template.New("Nebula configuration file")
	_, err := nebulaConfigTemplate.Funcs(sprig.HermeticTxtFuncMap()).Parse(configTemplate)
	if err != nil {
		return "", err
	}

	if err := nebulaConfigTemplate.Execute(&generatedConfig, ServerCfg.Nebula); err != nil {
		return "", err
	}

	return generatedConfig.String(), nil
}

// NebulaClientIP returns client's IP from IPAM
func NebulaClientIP() (string, error) {
	var gaidysResponse GaidysResponse
	url := ServerCfg.GaidysUrl + "/api/v1/hostname/" + ServerCfg.Login

	httpClient := &http.Client{}

	request, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return "", err
	}

	response, err := httpClient.Do(request)
	if err != nil {
		return "", err
	}

	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		return "", err
	}

	if err := json.Unmarshal(body, &gaidysResponse); err != nil {
		return "", err
	}

	// Currently return only IPv4
	return gaidysResponse.IpAddresses[0], nil
}

// NebulaGenerateCertificate generate ca.crt, client.crt, client.key for Nebula
func NebulaGenerateCertificate(userTeams []string) {
	crtPath := "/etc/nebula/certs/" + ServerCfg.Login + ".crt"
	keyPath := "/etc/nebula/certs/" + ServerCfg.Login + ".key"

	clientIP, err := NebulaClientIP()
	if err != nil {
		ServerCfg.Logger.Fatal("failed retrieving client's IP address", zap.Error(err))
	}

	if _, err := os.Stat(crtPath); err == nil {
		os.Remove(crtPath)
	}

	if _, err := os.Stat(keyPath); err == nil {
		os.Remove(keyPath)
	}

	err = exec.Command("/usr/local/nebula/nebula-cert",
		"sign", "-name", ServerCfg.Login,
		"-out-crt", crtPath,
		"-out-key", keyPath,
		"-ca-crt", "/etc/nebula/certs/ca.crt",
		"-ca-key", "/etc/nebula/certs/ca.key",
		"-ip", clientIP+"/12", "-groups", strings.Join(userTeams, ","),
		"-duration", "48h").Run()
	if err != nil {
		ServerCfg.Logger.Error(
			"Can't generate certificate for Nebula",
			zap.String("Login", ServerCfg.Login),
			zap.Strings("Teams", userTeams),
			zap.String("ClientIP", clientIP),
		)
	}

	ca, err := ioutil.ReadFile("/etc/nebula/certs/ca.crt")
	if err != nil {
		ServerCfg.Logger.Fatal("failed retrieving CA certificate", zap.Error(err))
	}

	crt, err := ioutil.ReadFile(crtPath)
	if err != nil {
		ServerCfg.Logger.Fatal("failed retrieving client certificate", zap.Error(err))
	}

	key, err := ioutil.ReadFile(keyPath)
	if err != nil {
		ServerCfg.Logger.Fatal("failed retrieving client key", zap.Error(err))
	}

	ServerCfg.Nebula.Certificate.Ca = string(ca)
	ServerCfg.Nebula.Certificate.Crt = string(crt)
	ServerCfg.Nebula.Certificate.Key = string(key)
}

// NebulaDownload used to download Nebula binary
func NebulaDownload() (err error) {
	err = os.Mkdir(NebulaDir(), 0755)
	if err != nil {
		return err
	}

	out, err := os.Create(NebulaExecutable())
	if err != nil {
		Cfg.Logger.Error("can't create Nebula binary",
			zap.String("Path", NebulaExecutable()),
			zap.Error(err))
		return err
	}
	defer out.Close()

	err = os.Chmod(NebulaExecutable(), 0755)
	if err != nil {
		Cfg.Logger.Error("can't change permissions for Nebula binary",
			zap.String("Path", NebulaExecutable()),
			zap.Error(err))
		return err
	}

	resp, err := http.Get(nebulaDownloadLink())
	if err != nil {
		Cfg.Logger.Error("can't download Nebula binary",
			zap.String("Url", nebulaDownloadLink()),
			zap.Error(err))
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed download Nebula: %s", resp.Status)
	}

	_, err = io.Copy(out, resp.Body)
	if err != nil {
		Cfg.Logger.Error("can't write Nebula binary",
			zap.String("Url", nebulaDownloadLink()),
			zap.String("Path", NebulaExecutable()),
			zap.Error(err))
		return err
	}

	return nil
}
